import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;

parser code {:
    public static int error = 0;
    public HashMap symbolTable;

    // Redefinition of error functions
    @Override
    public void report_error(String message, Object info) {
        error++;
        System.err.print(Main.file_name+":");
        if (info instanceof Symbol) {
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(line+":"+column+":");
            }
        }
        System.err.print(red(" error: "));
        System.err.println(message);
    }

    private String red(String str) {
        return "\u001B[31m" + str + "\u001B[0m";
    }

    @Override
    public void syntax_error(Symbol cur_token){}

    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }
    public void report(String message) {
        report_error(message, getToken());
    }

	public void debug(String message) {
		System.out.println(message);
	}
:};

init with {:
    symbolTable = new HashMap();
:}

// Terminal symbols
terminal VARIABLE, VECTOR, REAL;
terminal SO, SC, RO, RC, S, P, STAR, DIV, DOT, PLUS, MINUS, EQ, COMMA, QMARK;
terminal UMINUS;
// Non terminal symbols
non terminal ok, stmt_list, stmt_item, assignment;
non terminal variable_id, vector_id, scalar, vector, vector_item;
non terminal expression, sc_exp, vec_exp;
// Precedence of the operators
precedence left MINUS, PLUS;
precedence left DOT;
precedence left DIV, STAR;
precedence left P;
precedence left UMINUS;

// Start with the grammar

start with ok;

ok			::=	stmt_list QMARK	
				{: if (parser.error > 0) {
						System.out.println(parser.error+" errors generated");
					} 
				:};

stmt_list	::= stmt_list stmt_item S | stmt_item S;
stmt_item	::= assignment | expression;

assignment	::= variable_id EQ sc_exp
            |   vector_id EQ vec_exp;

variable_id ::= VARIABLE;
vector_id   ::= VECTOR;

scalar		::= REAL
            |   variable_id;

vector      ::= SO scalar COMMA scalar SC
            |   vector_id;

expression  ::= sc_exp | vec_exp;

sc_exp		::= sc_exp PLUS sc_exp
			|	sc_exp MINUS sc_exp
			|	sc_exp STAR sc_exp
			|	sc_exp DIV	sc_exp
			|	sc_exp P sc_exp
			|   RO sc_exp RC
            |   vec_exp DOT vec_exp
			|	MINUS sc_exp %prec UMINUS
            |   scalar;

vec_exp     ::= vec_exp PLUS vec_exp
			|	vec_exp MINUS vec_exp
			|   RO vec_exp RC
            |   sc_exp STAR vec_exp
            |   vec_exp STAR sc_exp
            |   sc_exp DIV vec_exp
            |   vec_exp DIV sc_exp
			|	MINUS vec_exp %prec UMINUS
            |   vector;
